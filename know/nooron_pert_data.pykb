# -*-mode: python -*-
put_direct_parents(['pert/pert_ontology'])
put_instance_types(current_kb(),['nooron_app_data'])
create_individual('Nooron_0_2_1',
                  pretty_name='Nooron 0.2.1',
                  direct_types=['Task'],
                  own_slots=[['EstimatedHours', 0],
                             ['Predecessors', ],
                             ['Status', 'complete'],
                             ['TaskDescription', """This is a dummy START job marking the state
              which was current when nooron_pert was begun."""],
                            ])
create_individual('PyOkbcCorrectness',
                  pretty_name='PyOkbc Correctness',
                  direct_types=['Task'],
                  own_slots=[['EstimatedHours', 3],
                             ['Predecessors', 'Nooron_0_2_1'],
                             ['Status', 'complete'],
                             ['TaskDescription', 'Fix bugs in get_slot_values, etc..'],
                            ])
create_individual('RunOnPort80',
                  pretty_name='Run On Port 80',
                  direct_types=['Task'],
                  own_slots=[['EstimatedHours', 2],
                             ['Predecessors', 'Nooron_0_2_1'],
                             ['Status', 'complete'],
                             ['TaskDescription', """Solve the 'starting on port 80' problem."""],
                            ])
create_individual('FleshOutPrimordialSlots',
                  pretty_name='Flesh Out Primordial Slots',
                  direct_types=['Task'],
                  own_slots=[['EstimatedHours', 2],
                             ['Predecessors', 'Nooron_0_2_1'],
                             ['Status', 'future'],
                             ['TaskDescription', """Attach appropriate constraint slots on the slots
              in the PRIMORDIAL_KB."""],
                            ])
create_individual('FormGeneration',
                  pretty_name='Form Generation',
                  direct_types=['Task'],
                  own_slots=[['EstimatedHours', 5],
                             ['Predecessors', 'FleshOutPrimordialSlots'],
                             ['Status', 'complete'],
                             ['TaskDescription', """Create very simple forms automatically by
              using widgets based on slot type."""],
                            ])
create_individual('OkbcConstraints',
                  direct_types=['Task'],
                  own_slots=[['EstimatedHours', 5],
                             ['Predecessors', 'FleshOutPrimordialSlots'],
                             ['Status', 'future'],
                             ['TaskDescription', """Create very simple forms automatically by
              using widgets based on slot type."""],
                            ])
create_individual('FormActions',
                  pretty_name='Form Actions',
                  direct_types=['Task'],
                  own_slots=[['EstimatedHours', 2],
                             ['Predecessors', 'FormGeneration', 'AuthorizationStubbedIn', 'OkbcConstraints'],
                             ['Status', 'complete'],
                             ['TaskDescription', """Write create_individual and create_class
              npts which are limited by authorization
              stubs.  method:add_slot_value """],
                            ])
create_individual('CriteriaAndEvaluationsOntology',
                  pretty_name='Criteria and Evaluations Ontology',
                  direct_types=['Task'],
                  own_slots=[['EstimatedHours', '24'],
                             ['Predecessors', 'Nooron_0_2_1'],
                             ['References', 'http://www.nooron.org/know/nooron_pattern_language/CriteriaAndEvaluations'],
                             ['Status', 'future'],
                             ['TaskDescription', 'Create initial ontology for Criteria and Evaluations.'],
                            ])
create_individual('CriteriaAndEvaluations',
                  pretty_name='Criteria and Evaluations',
                  direct_types=['Task'],
                  own_slots=[['EstimatedHours', 24],
                             ['Predecessors', 'FormActions', 'CriteriaAndEvaluationsOntology'],
                             ['Status', 'future'],
                             ['TaskDescription', 'Criteria and Evaluations'],
                            ])
create_individual('PyKb_save_kb',
                  pretty_name='PyKb save_kb',
                  direct_types=['Task'],
                  own_slots=[['EstimatedHours', '3'],
                             ['Predecessors', 'Nooron_0_2_1'],
                             ['References', ],
                             ['Status', 'complete'],
                             ['TaskDescription', 'Ensure that save_kb is working for PyKb.'],
                             ['TaskMotivation', ],
                             ['slot_display_order', ],
                            ])
create_individual('ThroughTheWebEditing',
                  pretty_name='Through-the-web editing',
                  direct_types=['Task'],
                  own_slots=[['EstimatedHours', 3],
                             ['Predecessors', 'PyKb_save_kb', 'HighPriorityForms', 'CreateInNooronData', 'RunOnPort80', 'PyOkbcCorrectness'],
                             ['Status', 'future'],
                             ['TaskDescription', 'Make it possible to at least add and edit frames.'],
                            ])
create_individual('AuthorizationStubbedIn',
                  pretty_name='Authorization Stubbed In',
                  direct_types=['Task'],
                  own_slots=[['EstimatedHours', 3],
                             ['Predecessors', 'Nooron_0_2_1'],
                             ['Status', 'future'],
                             ['TaskDescription', """Permit writing only when the user is visiting from
              some fixed IP address list, or when they have entered
              one of a list of userids."""],
                            ])
create_individual('DownloadableKBFiles',
                  pretty_name='Downloadable KB Files',
                  direct_types=['Task'],
                  own_slots=[['EstimatedHours', '2'],
                             ['Predecessors', 'Nooron_0_2_1'],
                             ['Status', 'future'],
                             ['TaskDescription', 'Deliver a pykb export of somekb at the URL /know/some_kb.pykb ', """Make raw knowledge surfable.  Support backup, export, mirroring, interoperation and distributedness.
"""],
                             ['slot_display_order', ],
                            ])
create_individual('NPTsInSubdirs',
                  pretty_name='NPTs in Subdirectories',
                  direct_types=['Task'],
                  own_slots=[['EstimatedHours', 4],
                             ['Predecessors', 'Nooron_0_2_1'],
                             ['Status', 'future'],
                             ['TaskDescription', """Ensure that NPTs can live in subdirectories of
              /know (such as /know/pert) and be accessed appropriately."""],
                            ])
create_individual('NooronAppRegistry',
                  pretty_name='Nooron App Registry',
                  direct_types=['Task'],
                  own_slots=[['EstimatedHours', 2],
                             ['Predecessors', 'NPTsInSubdirs'],
                             ['Status', 'future'],
                             ['TaskDescription', 'Create KB containing information about Nooron Apps.'],
                            ])
create_individual('RemotelyInheritNooronApps',
                  pretty_name='Remotely Inherit Nooron Apps',
                  direct_types=['Task'],
                  own_slots=[['EstimatedHours', 8],
                             ['Predecessors', 'SubdirsAsKBs', 'DownloadableKBFiles', 'TellKb'],
                             ['Status', 'future'],
                             ['TaskDescription', """Make it possible for someone to create a
              nooron_app_instance which points to a nooron_app_wardrobe
              which actually lives on a different machine, and have it
              all work."""],
                            ])
create_individual('SubdirsAsKBs',
                  pretty_name='Subdirs as KBs',
                  direct_types=['Task'],
                  own_slots=[['EstimatedHours', 3],
                             ['Predecessors', 'Nooron_0_2_1'],
                             ['Status', 'future'],
                             ['TaskDescription', """Make subdirectories of /know, (e.g. /know/pert)
              themselves be KBs.  They need to be surfable and
              representable as .tell or .pykb, ultimately."""],
                            ])
create_individual('EncodingPipelines',
                  pretty_name='Encoding Pipelines',
                  direct_types=['Task'],
                  own_slots=[['EstimatedHours', '6'],
                             ['Predecessors', 'Nooron_0_2_1'],
                             ['Status', 'complete'],
                             ['TaskDescription', """Ensure that sequences of extensions (e.g. tar.gz,
              .dot.svg, or .dbk.pdf) properly transform the output.
              All relationships between content-types and their legal
              encodings to be managed as knowledge."""],
                             ['slot_display_order', ],
                            ])
create_individual('CachedOutput',
                  pretty_name='Cached Output',
                  direct_types=['Task'],
                  own_slots=[['EstimatedHours', 8],
                             ['Predecessors', 'EncodingPipelines'],
                             ['Status', 'complete'],
                             ['TaskDescription', """Devise a system of request parameter hashing
              so that output is only regenerated when needed and
              that intermediate forms as well as encodings of them
              are appropriately cached and delivered.  For example,
              nooron_pattern_language.dot would be cached as would
              nooron_pattern_language.dot.pdf.  The .dot would be
              regenerated only when the knowledge or template changed.
              The .pdf would only be regenerated from cached .dot
              when the .dot changed.  A system of hashes based on
              canonical forms of the requests with knowledge, template
              and preferences mixed in ought to do it.
              """],
                            ])
create_individual('DiskCacheFlushing',
                  pretty_name='Disk Cache Flushing',
                  direct_types=['Task'],
                  own_slots=[['EstimatedHours', 3],
                             ['Predecessors', 'CachedOutput'],
                             ['Status', 'future'],
                             ['TaskDescription', 'Delete items in the disk cache when they are stale.'],
                            ])
create_individual('CachingMixin',
                  pretty_name='Caching Mixin',
                  direct_types=['Task'],
                  own_slots=[['EstimatedHours', 3],
                             ['Predecessors', 'Nooron_0_2_1'],
                             ['Status', 'complete'],
                             ['TaskDescription', """Put wrapper functions around all kb read operations
              which cache the output keyed on the paremeters."""],
                            ])
create_individual('TellKb',
                  direct_types=['Task'],
                  own_slots=[['EstimatedHours', 3],
                             ['Predecessors', 'Nooron_0_2_1'],
                             ['Status', 'future'],
                             ['TaskDescription', 'Get TellKb working correctly for reading and saving.'],
                            ])
create_individual('CentralAppRegistry',
                  pretty_name='Central Registry of Nooron Apps',
                  direct_types=['Task'],
                  own_slots=[['EstimatedHours', 3],
                             ['Predecessors', 'ThroughTheWebEditing', 'NooronAppRegistry', 'RemotelyInheritNooronApps'],
                             ['Status', 'future'],
                             ['TaskDescription', """Create a Central Registry of Nooron Apps where the
              apps themselves exist remotely."""],
                            ])
create_individual('NotSoBasicAuthentication',
                  pretty_name='Not So Basic Authentication',
                  direct_types=['Task'],
                  own_slots=[['EstimatedHours', 6],
                             ['Predecessors', 'Nooron_0_2_1'],
                             ['References', 'http://www.nooron.org/know/nooron_pattern_language/NotSoBasicAuthentication'],
                             ['Status', 'future'],
                             ['TaskDescription', """Users enter an url (root-relative or absolute with fqdn)
              as their userid and a password which when crypted must
              equal a crypted value in the NSBA-KB at the url."""],
                            ])
create_individual('UserPreferredGarments',
                  pretty_name='User-Preferred Garments',
                  direct_types=['Task'],
                  own_slots=[['EstimatedHours', 4],
                             ['Predecessors', 'NotSoBasicAuthentication'],
                             ['References', ],
                             ['Status', 'future'],
                             ['TaskDescription', """Defer to a user's preferences in their NSBA-KB for
              things such as the garment to default to for instances
              of each class.  Maybe when authenticated users surf a
              nooron site, when they visit a kb, it should be with their
              NSBA-KB as a parent, to avoid complicated look-aside."""],
                            ])
create_individual('UserBasedAuthorization',
                  pretty_name='User-based Authorization',
                  direct_types=['Task'],
                  own_slots=[['EstimatedHours', 50],
                             ['Predecessors', 'NotSoBasicAuthentication', 'AuthorizationStubbedIn'],
                             ['References', 'http://www.erights.org'],
                             ['Status', 'future'],
                             ['TaskDescription', """Permit read, write, modify and other registerable
              capabilities based on the who the user has authenticated
              themselves as.  Seriously examine capabilities as
              implemented in E before tackling this task."""],
                            ])
create_individual('HTMLWithPictures',
                  pretty_name='HTML with Pictures',
                  direct_types=['Task'],
                  own_slots=[['EstimatedHours', 2],
                             ['Predecessors', 'CachedOutput'],
                             ['Status', 'complete'],
                             ['TaskDescription', 'Put pictures (.jpg,.svg) from graphviz in html.'],
                            ])
create_individual('DocBookWithPictures',
                  pretty_name='DocBook with Pictures',
                  direct_types=['Task'],
                  own_slots=[['EstimatedHours', 4],
                             ['Predecessors', 'CachedOutput'],
                             ['Status', 'future'],
                             ['TaskDescription', 'Connive to insert images into docbook output, URLs for the remote renderings and cached files for the local renderings (such as PS and PDF).  This is the tricky part, refactoring the code so that the name of the appropriate cached version of the image is emitted in the docbook output.  This is starting to strain [indeed!] the whole business about the cached files having those silly MD5 names.  Maybe its time to make the cached file names exactly match the paths in the URLs which invoke them.'],
                            ])
create_individual('CreateInNooronData',
                  pretty_name='Create in nooron_app_data kbs',
                  direct_types=['Task'],
                  own_slots=[['EstimatedHours', '3'],
                             ['Predecessors', 'Nooron_0_2_1'],
                             ['References', ],
                             ['Status', 'complete'],
                             ['TaskDescription', """When adding frames which are instances of a
              nooron_app_class, those instances should be created in
              the appropriate nooron_app_data kb."""],
                             ['TaskMotivation', ],
                             ['slot_display_order', ],
                            ])
create_individual('HighPriorityForms',
                  pretty_name='High Priority Forms',
                  direct_types=['Task'],
                  own_slots=[['EstimatedHours', '6'],
                             ['Predecessors', 'FormActions'],
                             ['References', ''],
                             ['Status', 'future'],
                             ['TaskDescription', 'Create forms to support project management and pattern language maintenance.'],
                            ])
create_individual('PDFwithPictures',
                  pretty_name='PDF with Pictures',
                  direct_types=['Task'],
                  own_slots=[['EstimatedHours', '2'],
                             ['Predecessors', 'DocBookWithPictures'],
                             ['References', ''],
                             ['Status', 'future'],
                             ['TaskDescription', ''],
                            ])
create_individual('ImprovingContent',
                  pretty_name='Improving Content',
                  direct_types=['Task'],
                  own_slots=[['EstimatedHours', '6'],
                             ['Predecessors', 'CriteriaAndEvaluations'],
                             ['References', ''],
                             ['Status', 'future'],
                             ['TaskDescription', 'Use Criteria and Evaluations to improve knowledge (including frames and garments)'],
                            ])
create_individual('CentralRegistryOfEvolvingApps',
                  pretty_name='Central Registry of Evolving Apps',
                  direct_types=['Task'],
                  own_slots=[['EstimatedHours', '6'],
                             ['Predecessors', 'ImprovingContent', 'CentralAppRegistry'],
                             ['References', ''],
                             ['Status', 'future'],
                             ['TaskDescription', 'Combine Criteria and Evaluations with the App Registry so that Nooron Apps can undergo collaborative filtering and collaborative amelioration.'],
                            ])
create_individual('DistributedRegistryOfEvolvingApps',
                  pretty_name='Distributed Registry of Evolving Apps',
                  direct_types=['Task'],
                  own_slots=[['EstimatedHours', '6'],
                             ['Predecessors', 'CentralRegistryOfEvolvingApps'],
                             ['References', ''],
                             ['Status', 'future'],
                             ['TaskDescription', 'Create distributed system for using collaborative filtration to discover evolving apps.'],
                            ])
create_individual('FilteredKnowledgeAcquisition',
                  pretty_name='Filtered Knowledge Acquisition',
                  direct_types=['Task'],
                  own_slots=[['EstimatedHours', '6'],
                             ['Predecessors', 'EvolvingAppRegistry'],
                             ['References', ''],
                             ['Status', 'future'],
                             ['TaskDescription', 'Acquire knowledge from multiple instances of the same Nooron App.'],
                            ])
create_individual('DistributedEncyclopedia',
                  pretty_name='Distributed Encyclopedia',
                  direct_types=['Task'],
                  own_slots=[['EstimatedHours', '6'],
                             ['Predecessors', 'FilteredKnowledgeAcquisition'],
                             ['References', ''],
                             ['Status', 'future'],
                             ['TaskDescription', 'Combine Criteria and Evaluations with the App Registry so that Nooron Apps can undergo collaborative filtering and collaborative amelioration.'],
                            ])
create_individual('KnowledgeDrivenSecurity',
                  pretty_name='Knowledge Driven Security',
                  direct_types=['Task'],
                  own_slots=[['EstimatedHours', '20'],
                             ['Predecessors', 'UserBasedAuthorization'],
                             ['References', ''],
                             ['Status', 'future'],
                             ['TaskDescription', """Create a chainable security engine (compatible with IPListSecurityEngine) which permits per-kb-type, per-KB, per-Class, per-Slot, per-Facet and per-Individual security controls.  The security engine would be more robust if included in PyOKBC (rather than tacked on at the Nooron level) but this is unclear.  This is a large task and perhaps ought to be broken up into smaller bites.  The first priority is to ensure that transformers can't be hijacked to perform arbitrary operations on disk.  The second priority is to ensure that arbitrary read and write operations can't be performed under the aegis of KB reading and writing."""],
                             ['TaskMotivation', 'The benefits of the expected security include: very fine grain, secure enough for public use, flexible enough for public use.'],
                            ])
create_individual('UsersCreateKBs',
                  pretty_name='Users Create KBs',
                  direct_types=['Task'],
                  own_slots=[['EstimatedHours', '2'],
                             ['Predecessors', 'KnowledgeDrivenSecurity'],
                             ['References', 'http://www.ai.sri.com/~okbc/spec/okbc2/okbc2.html'],
                             ['Status', 'future'],
                             ['TaskDescription', 'Expose the create_kb method.'],
                             ['TaskMotivation', 'Make spontaneous use of Nooron possible by the public.'],
                            ])
create_individual('SeparateKBsFromCodebase',
                  pretty_name='Separate KBs From Codebase',
                  direct_types=['Task'],
                  own_slots=[['EstimatedHours', '4'],
                             ['Predecessors', 'ThroughTheWebEditing'],
                             ['References', ''],
                             ['Status', 'future'],
                             ['TaskDescription', 'Decide which KBs to keep in the distribution.  Will simply adjusting the location of /know in the startup script suffice?  Create backup mechanisms for the newly independent /know directory.  Possibly setup CVS management of the KBs.  Examine the distinction between ontologies, wardrobes and app_instances.  Is there more factoring which should happen at this time?  Perhaps separate the app cores from the app instances.  This leads into the remote inheritance issue and the nooron/noosphere distinction.'],
                             ['TaskMotivation', 'There are now a large number of KBs, they should no longer encumber the Nooron codebase nor themselves be disturbed by the software release cycle.'],
                            ])
create_individual('PluggableAuthenticationAgainstFavors',
                  pretty_name='Pluggable Authentication Against Favors',
                  direct_types=['Task'],
                  own_slots=[['EstimatedHours', '3'],
                             ['Predecessors', 'PortToPython22', 'UserBasedAuthorization'],
                             ['References', 'http://www.favors.org'],
                             ['Status', 'future'],
                             ['TaskDescription', """Implement Tom Munnecke's xmlrpc code for authenticating against Friendly Favors as the first Pluggable Authenticator for Nooron."""],
                             ['TaskMotivation', 'Provide value to the Friendly Favors crowd.  Garner a user community for Nooron.  Would this really be a user community for Noosphere?'],
                             ['slot_display_order', ],
                            ])
create_individual('PortToPython22',
                  pretty_name='Port to Python 2.2',
                  direct_types=['Task'],
                  own_slots=[['EstimatedHours', '4'],
                             ['Predecessors', 'Nooron_0_2_1'],
                             ['References', ''],
                             ['Status', 'future'],
                             ['TaskDescription', 'Figure out what the heck is interferring with PyOKBC running on Python 2.2 and then fix it.'],
                             ['TaskMotivation', 'Python 2.2 has nice features like chroot support and xmlrpc which comes in handy for the Favors Pluggable Authenticator.'],
                            ])
create_individual('GetGarmentsRecursing',
                  pretty_name='Get Garments Recursing',
                  direct_types=['Task'],
                  own_slots=[['EstimatedHours', '4'],
                             ['Predecessors', 'EncodingPipelines'],
                             ['References', ''],
                             ['Status', 'future'],
                             ['TaskDescription', """D'oh.  ZPTs don't seem to be recursive.  Quintuple blast!  Either develop workarounds, query Guido on the nature of the fix, dive in and do it or rethink ZPTs.  Workarounds might include iterative approaches to some things, or leaning on OKBC Procedures for some formatting work.  Sigh.  The longterm goal is certainly to have the Garment mechanism capable of recursion though, so a fundamental solution is preferred."""],
                             ['TaskMotivation', 'Things like DocBook Book output which presents nested KBs as nested book sections depend on recursive garments.  Likewise nested graphics such as linguistic_shell_contain_hier.dot'],
                            ])
